---
title: MatchRes
description: Pattern-match on Result types using `matchRes` for clear error handling.
---

## Matching Results

When working with `Result` types, we often need to handle both success and failure cases. The `matchRes` utility provides a structured, type-safe way to process these outcomes without resorting to nested conditionals or unsafe value extraction.

### What is `matchRes`?

`matchRes` is a pattern-matching utility designed specifically for `Result` types. It enforces exhaustive handling of both success (`Ok`) and failure (`Err`) cases through a clean, declarative syntax. This approach eliminates guesswork and ensures all possible outcomes are addressed.

### When to Use `matchRes`

#### Ideal Scenarios:
- **Safe Value Extraction**  
  When you need to work with values inside `Result` without risking unchecked errors

- **Clean Branching**  
  When you want to replace nested conditionals with declarative logic

### How It Works

`matchRes` requires you to define handlers for both possible `Result` states:

```ts
const transactionResult: Result<Receipt, Error> = processPayment();

// Simple matching
matchRes(transactionResult, {
  Ok: (receipt) => saveReceipt(receipt),
  Err: (error) => logPaymentError(error)
});
```

