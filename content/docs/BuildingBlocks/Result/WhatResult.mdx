---
title: What is Result?
description: Learn how the Result type provides explicit, type-safe error handling in functional programming.
---

# What is `Result`?

In robust software design, we need clear ways to handle operations that may fail. The `Result` type gives us structured error handling that keeps failures visible and manageable. Unlike exception-based approaches that hide error paths, `Result` makes success and failure cases equally explicit in your code's type signatures.

## Why Result Matters

`Result` addresses error-handling by making errors first-class citizens. When you see `Result`, you immediately understand:
- The operation may fail
- The exact error type is specified
- Both outcomes must be handled

## Understanding Result

The `Result` type has two fundamental variants:

- `Ok(value)`: Wraps a successful computation result
- `Err(error)`: Contains detailed failure information

This simple dichotomy forces you to confront error cases explicitly, leading to more reliable code.

```ts
// Successful operation
const success: Result<number, string> = Result.Ok(42);

// Failed operation
const failure: Result<number, string> = Result.Err("Invalid input");

// Function returning Result
function divide(a: number, b: number): Result<number, string> {
  return b === 0 
    ? Result.Err("Division by zero") 
    : Result.Ok(a / b);
}
```

## Key Benefits

### Type-Safe Error Handling
Compiler-enforced handling of both success and failure paths means no forgotten error cases.

### Maintained Error Context
Errors propagate through your pipeline without losing valuable debugging information.

### Composable Operations
Chain transformations cleanly using:
- `map` for value transformations
- `flatMap` for operation sequencing
- `match` for exhaustive case handling

```ts
// Using match for exhaustive handling
divide(10, 2).match({
  Ok: value => console.log(`Result: ${value}`),
  Err: error => console.error(`Error: ${error}`)
});

// Unwrapping safely
const value = divide(10, 2).unwrapOr(0);
```

## Ideal Use Cases

`Result` shines when:
- Dealing with predictable failure modes (API calls, IO operations)
- Building complex operation pipelines
- Writing critical code where all failures must be handled
- Working in functional-style codebases

```ts
// Chaining operations
const result = getUserById(123)
  .flatMap(user => getProfile(user.id))
  .map(profile => profile.email)
  .mapErr(error => `Failed: ${error}`);

// Async example
async function fetchData(): Promise<Result<Data, Error>> {
  return fetch(url)
    .then(res => res.ok 
      ? Result.Ok(await res.json()) 
      : Result.Err(new Error(res.statusText))
    .catch(err => Result.Err(err));
}
```

## Comparison

<GoodBadCode
  goodDescription="Result Advantages:"
  goodPoints={[
    "Maintained error context through chains",
    "No unexpected control flow breaks"
  ]}
  badDescription="Exception Pitfalls:"
  badPoints={[
    "Invisible error paths in types",
    "Lost stack traces and context",
    "Optional catch blocks",
    "Unpredictable control flow"
  ]}
  goodCode={`// With Result
function getUser(): Result<User, APIError> {
  return fetchUser()
    .flatMap(validateUser)
    .mapErr(apiErrorMapper);
}`}
  badCode={`// With exceptions
function getUser(): User {
  try {
    const user = fetchUser();
    return validateUser(user); // Throws on invalid
  } catch (e) {
    // Lost original error context
    throw new Error("Failed to get user");
  }
}`}
  showViewButton={true}
/>
