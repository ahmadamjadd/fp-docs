---
title: What is Result?
description: Learn how the Result type provides explicit, type-safe error handling in functional programming.
---

The Result type in solves error handling in JavaScript and TypeScript by introducing explicit, functional, and composable mechanisms for managing success and failure. This eliminates the ambiguity and fragility of traditional try/catch.
## Why Result Matters

`Result` addresses error-handling by making errors first-class citizens. When you see `Result`, you immediately understand:
- The operation may fail
- Both outcomes (success and failure) must be handled

## Understanding Result

The `Result` type has two fundamental variants:

- `Ok(value)`: Wraps a successful computation result
- `Err(error)`: Contains detailed failure information

This simple dichotomy forces you to confront error cases explicitly, leading to more reliable code.

```ts
// Successful operation
const success: Result<number, string> = Result.Ok(42);

// Failed operation
const failure: Result<number, string> = Result.Err("Invalid input");

// Function returning Result
function divide(a: number, b: number): Result<number, string> {
  return b === 0 
    ? Result.Err("Division by zero") 
    : Result.Ok(a / b);
}
```

## Key Benefits

### No forgotten Error Handling
Compiler-enforced handling of both success and failure paths means no forgotten error cases.


### Composable Operations
Chain transformations cleanly using:
- `map` for value transformations
- `flatMap` for operation sequencing
- `matchRes` for exhaustive case handling

```ts
// Using match for exhaustive handling
divide(10, 2).match({
  Ok: value => console.log(`Result: ${value}`),
  Err: error => console.error(`Error: ${error}`)
});

// Unwrapping safely
const value = divide(10, 2).unwrapOr(0);
```

## Ideal Use Cases

`Result` shines when:
- Dealing with predictable failure modes
- Building complex operation pipelines
- Writing critical code where all failures must be handled

```ts
// Chaining operations
const result = getUserById(123)
  .flatMap(user => getProfile(user.id))
  .map(profile => profile.email)
  .mapErr(error => `Failed: ${error}`);

// Async example
async function fetchData(): Promise<Result<Data, Error>> {
  return fetch(url)
    .then(res => res.ok 
      ? Result.Ok(await res.json()) 
      : Result.Err(new Error(res.statusText))
    .catch(err => Result.Err(err));
}
```

## Comparison

<GoodBadCode
  goodDescription="Result Advantages:"
  goodPoints={[
    "Maintained error context through chains",
    "No unexpected control flow breaks"
  ]}
  badDescription="Exception Pitfalls:"
  badPoints={[
    "Might forget any error"
  ]}
  goodCode={`// With Result
function getUser(): Result<User, APIError> {
  return fetchUser()
    .flatMap(validateUser)
    .mapErr(apiErrorMapper);
}`}
  badCode={`// With exceptions
function getUser(): User {
  try {
    const user = fetchUser();
    return validateUser(user); // Throws on invalid
  } catch (e) {
    // Lost original error context
    throw new Error("Failed to get user");
  }
}`}
  showViewButton={true}
/>
