---
title: Expected vs Unexpected Errors
description: Understand the crucial difference between expected and unexpected errors in programming.
---

# Two Types of Errors

Every program deals with two fundamentally different kinds of failures:

## Expected Errors
These are failures we anticipate and design for:
- A file is not found
- An item doesn’t exist in a database
- A login fails due to wrong credentials

They represent normal program flow and should be:
- Preventable or recoverable
- Anticipated during design
- Handled explicitly using types like `Result`, `Option`

```ts
// Expected failure - API response
function fetchUser(id: string): Result<User, "NotFound" | "NetworkError"> {
  try {
    const user = await api.get(`/users/${id}`);
    return Result.Ok(user);
  } catch (e) {
    return e.status === 404 
      ? Result.Err("NotFound")
      : Result.Err("NetworkError");
  }
}

// Usage (must handle both cases)
fetchUser("123").match({
  Ok: user => renderProfile(user),
  Err: error => showErrorToast(error) // "NotFound" | "NetworkError"
});
```

## Unexpected Errors
These represent genuine system defects:
- Stack overflows
- Syntax errors in code
- Misuse of an API
- Uncaught exceptions in 3rd-party libraries

They indicate:
- Bugs rather than normal cases
- Conditions we can't reasonably recover from
- Problems outside expected behavior
```ts
function recurse() {
  recurse(); // no base case
}

recurse(); // ❌ RangeError: Maximum call stack size exceeded

```

## Why the Distinction Matters

1. **Clearer Code**  
   Separates normal failures from actual bugs

2. **Better Reliability**  
   Forces handling of anticipated cases

3. **Cleaner Architecture**  
   Isolates recoverable vs unrecoverable paths


**Carbonteq FP provides tools to handle expected errors effectively, as we'll explore in this documentation.**